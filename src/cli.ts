#!/usr/bin/env node
// src/cli.ts
// SpecSpec CLI - validate targets against spec files

import path from 'node:path';
import fs from 'node:fs';
import { pathToFileURL } from 'node:url';
import { SpecEngine } from './engine.js';
import { generateDoc } from './doc.js';
import { generatePython } from './codegen/index.js';
import { Type, Modifier } from './base.js';

const args = process.argv.slice(2);

// Help message
const help = `
SpecSpec - Validate targets against spec files

Usage:
  specspec <spec-file> <target-path> [options]
  specspec <spec-file> --doc [options]
  specspec <spec-file> --codegen <lang> [options]
  specspec --init [name]

Options:
  -t, --types <file>   Load custom types (can be used multiple times)
  --json               Output results as JSON
  --doc                Generate Markdown documentation from spec file
  --codegen <lang>     Generate validator code (supported: python)
  -o, --output <file>  Write output to file instead of stdout
  --help, -h           Show this help message
  --version, -v        Show version

Commands:
  --init [name]        Create a sample spec file (default: spec.js)

Examples:
  specspec package.spec.js ./my-project
  specspec Spec.js ./bundle -t ./core.mjs -t ./oauth.mjs
  specspec Spec.js --doc -o README.md
  specspec Spec.js --codegen python -o validator.py
  specspec --init

Custom Types:
  Export types as named exports, then load with -t:
    specspec spec.js target -t ./my-types.mjs
`;

// Version
function showVersion() {
  const pkgPath = path.resolve(import.meta.dirname, '../package.json');
  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
  console.log(pkg.version);
}

// Init template
const specTemplate = `// Spec file generated by SpecSpec
// Usage: specspec <this-file> <target-path>

// Reusable field definitions
const NameField = Field({ key: 'name', value: Str({ minLength: 1 }) });
const VersionField = Field({ key: 'version', value: Str({ match: /^\\d+\\.\\d+\\.\\d+/ }) });

// Root spec - validates target directory
Directory({
  content: {
    required: [
      JsonFile({
        path: 'package.json',
        required: [NameField, VersionField],
        optional: [
          Field({ key: 'description', value: Str(), optional: true }),
          Field({ key: 'main', value: Str(), optional: true }),
          Field({ key: 'license', value: OneOf('MIT', 'Apache-2.0', 'ISC', Str()), optional: true })
        ]
      })
    ],
    optional: [
      File({ path: 'README.md' }),
      File({ path: 'LICENSE' }),
      Directory({ path: 'src' }),
      Directory({ path: 'test' })
    ]
  }
})
`;

function init(name: string = 'spec.js') {
  const filePath = path.resolve(process.cwd(), name);
  if (fs.existsSync(filePath)) {
    console.error(`Error: File already exists: ${filePath}`);
    process.exit(1);
  }
  fs.writeFileSync(filePath, specTemplate);
  console.log(`Created: ${filePath}`);
  console.log(`\nRun validation with:`);
  console.log(`  specspec ${name} <target-path>`);
}

// Parse options
interface Options {
  specFile?: string;
  targetPath?: string;
  typesFiles: string[];
  json?: boolean;
  doc?: boolean;
  codegen?: string;
  output?: string;
}

function parseArgs(args: string[]): Options {
  const opts: Options = { typesFiles: [] };
  const positional: string[] = [];

  for (let i = 0; i < args.length; i++) {
    const arg = args[i]!;
    if (arg === '-t' || arg === '--types') {
      const nextArg = args[++i];
      if (nextArg) opts.typesFiles.push(nextArg);
    } else if (arg === '--json') {
      opts.json = true;
    } else if (arg === '--doc') {
      opts.doc = true;
    } else if (arg === '--codegen') {
      const nextArg = args[++i];
      if (nextArg) opts.codegen = nextArg;
    } else if (arg === '-o' || arg === '--output') {
      const nextArg = args[++i];
      if (nextArg) opts.output = nextArg;
    } else if (!arg.startsWith('-')) {
      positional.push(arg);
    }
  }

  if (positional[0]) opts.specFile = positional[0];
  if (positional[1]) opts.targetPath = positional[1];
  return opts;
}

async function validate(opts: Options) {
  const specPath = path.resolve(process.cwd(), opts.specFile!);
  const target = path.resolve(process.cwd(), opts.targetPath!);

  // Check spec file exists
  if (!fs.existsSync(specPath)) {
    if (opts.json) {
      console.log(JSON.stringify({ ok: false, issues: [{ level: 'error', code: 'spec.not_found', message: `Spec file not found: ${specPath}`, path: [] }] }));
    } else {
      console.error(`Error: Spec file not found: ${specPath}`);
    }
    process.exit(1);
  }

  // Check target exists
  if (!fs.existsSync(target)) {
    if (opts.json) {
      console.log(JSON.stringify({ ok: false, issues: [{ level: 'error', code: 'target.not_found', message: `Target not found: ${target}`, path: [] }] }));
    } else {
      console.error(`Error: Target not found: ${target}`);
    }
    process.exit(1);
  }

  // Load custom types if specified
  const customTypes: Record<string, unknown> = {};
  const loadedTypesFiles: string[] = [];

  for (const typesFile of opts.typesFiles) {
    const typesPath = path.resolve(process.cwd(), typesFile);
    if (!fs.existsSync(typesPath)) {
      if (opts.json) {
        console.log(JSON.stringify({ ok: false, issues: [{ level: 'error', code: 'types.not_found', message: `Types file not found: ${typesPath}`, path: [] }] }));
      } else {
        console.error(`Error: Types file not found: ${typesPath}`);
      }
      process.exit(1);
    }

    try {
      // Use file:// URL for dynamic import on all platforms
      const typesUrl = pathToFileURL(typesPath).href;
      const module = await import(typesUrl);
      // Filter out non-type exports (like Type class itself)
      for (const [key, value] of Object.entries(module)) {
        if (key !== 'default' && typeof value === 'function') {
          customTypes[key] = value;
        } else if (key !== 'default' && typeof value === 'object' && value !== null) {
          // Instance types like SemVersion
          customTypes[key] = value;
        }
      }
      loadedTypesFiles.push(typesPath);
    } catch (err) {
      if (opts.json) {
        console.log(JSON.stringify({ ok: false, issues: [{ level: 'error', code: 'types.load_error', message: `Failed to load types from ${typesPath}: ${(err as Error).message}`, path: [] }] }));
      } else {
        console.error(`Error loading types file ${typesPath}: ${(err as Error).message}`);
      }
      process.exit(1);
    }
  }

  if (!opts.json) {
    console.log(`Spec:   ${specPath}`);
    console.log(`Target: ${target}`);
    if (loadedTypesFiles.length > 0) {
      console.log(`Types:  ${loadedTypesFiles.join(', ')}`);
      console.log(`        (${Object.keys(customTypes).join(', ')})`);
    }
    console.log('');
  }

  const engine = new SpecEngine();
  if (Object.keys(customTypes).length > 0) {
    engine.register(customTypes);
  }
  const result = engine.run(specPath, target);

  if (opts.json) {
    console.log(JSON.stringify(result, null, 2));
    process.exit(result.ok ? 0 : 1);
  }

  if (result.ok) {
    console.log('\x1b[32m✓ Validation passed\x1b[0m');
    process.exit(0);
  } else {
    console.log('\x1b[31m✗ Validation failed\x1b[0m\n');
    for (const issue of result.issues) {
      const levelColor = issue.level === 'error' ? '\x1b[31m' : '\x1b[33m';
      const pathStr = issue.path.length > 0 ? issue.path.join('.') : '(root)';
      console.log(`${levelColor}[${issue.level}]\x1b[0m ${issue.code}`);
      console.log(`  ${issue.message}`);
      console.log(`  at: ${pathStr}\n`);
    }
    process.exit(1);
  }
}

async function generateDocumentation(opts: Options) {
  const specPath = path.resolve(process.cwd(), opts.specFile!);

  // Check spec file exists
  if (!fs.existsSync(specPath)) {
    console.error(`Error: Spec file not found: ${specPath}`);
    process.exit(1);
  }

  // Load custom types if specified
  const customTypes: Record<string, unknown> = {};
  for (const typesFile of opts.typesFiles) {
    const typesPath = path.resolve(process.cwd(), typesFile);
    if (!fs.existsSync(typesPath)) {
      console.error(`Error: Types file not found: ${typesPath}`);
      process.exit(1);
    }

    try {
      const typesUrl = pathToFileURL(typesPath).href;
      const module = await import(typesUrl);
      for (const [key, value] of Object.entries(module)) {
        if (key !== 'default' && typeof value === 'function') {
          customTypes[key] = value;
        } else if (key !== 'default' && typeof value === 'object' && value !== null) {
          customTypes[key] = value;
        }
      }
    } catch (err) {
      console.error(`Error loading types file ${typesPath}: ${(err as Error).message}`);
      process.exit(1);
    }
  }

  // Create engine and parse spec to get root type
  const engine = new SpecEngine();
  if (Object.keys(customTypes).length > 0) {
    engine.register(customTypes);
  }

  // Parse spec file to get root type (use engine's internal method)
  const root = engine.parseSpec(specPath);
  if (!root) {
    console.error('Error: Failed to parse spec file or no root type defined');
    process.exit(1);
  }

  // Generate documentation
  const doc = generateDoc(root as Type | Modifier);

  // Output
  if (opts.output) {
    const outPath = path.resolve(process.cwd(), opts.output);
    fs.writeFileSync(outPath, doc);
    console.log(`Documentation written to: ${outPath}`);
  } else {
    console.log(doc);
  }
}

async function generateCode(opts: Options) {
  const specPath = path.resolve(process.cwd(), opts.specFile!);
  const lang = opts.codegen!;

  // Check spec file exists
  if (!fs.existsSync(specPath)) {
    console.error(`Error: Spec file not found: ${specPath}`);
    process.exit(1);
  }

  // Check supported language
  const supportedLangs = ['python'];
  if (!supportedLangs.includes(lang)) {
    console.error(`Error: Unsupported language: ${lang}`);
    console.error(`Supported languages: ${supportedLangs.join(', ')}`);
    process.exit(1);
  }

  // Load custom types if specified
  const customTypes: Record<string, unknown> = {};
  for (const typesFile of opts.typesFiles) {
    const typesPath = path.resolve(process.cwd(), typesFile);
    if (!fs.existsSync(typesPath)) {
      console.error(`Error: Types file not found: ${typesPath}`);
      process.exit(1);
    }

    try {
      const typesUrl = pathToFileURL(typesPath).href;
      const module = await import(typesUrl);
      for (const [key, value] of Object.entries(module)) {
        if (key !== 'default' && typeof value === 'function') {
          customTypes[key] = value;
        } else if (key !== 'default' && typeof value === 'object' && value !== null) {
          customTypes[key] = value;
        }
      }
    } catch (err) {
      console.error(`Error loading types file ${typesPath}: ${(err as Error).message}`);
      process.exit(1);
    }
  }

  // Create engine and parse spec to get root type
  const engine = new SpecEngine();
  if (Object.keys(customTypes).length > 0) {
    engine.register(customTypes);
  }

  const root = engine.parseSpec(specPath);
  if (!root) {
    console.error('Error: Failed to parse spec file or no root type defined');
    process.exit(1);
  }

  // Get type description
  const desc = (root as Type | Modifier).describe();

  // Generate code
  let code: string;
  if (lang === 'python') {
    code = generatePython(desc);
  } else {
    console.error(`Error: Code generation not implemented for: ${lang}`);
    process.exit(1);
  }

  // Output
  if (opts.output) {
    const outPath = path.resolve(process.cwd(), opts.output);
    fs.writeFileSync(outPath, code);
    console.log(`Generated ${lang} validator: ${outPath}`);
  } else {
    console.log(code);
  }
}

// Main
async function main() {
  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    console.log(help);
    process.exit(0);
  }

  if (args.includes('--version') || args.includes('-v')) {
    showVersion();
    process.exit(0);
  }

  if (args[0] === '--init') {
    init(args[1]);
    process.exit(0);
  }

  const opts = parseArgs(args);

  if (!opts.specFile) {
    console.error('Error: Missing spec file');
    console.log(help);
    process.exit(1);
  }

  // Documentation mode
  if (opts.doc) {
    await generateDocumentation(opts);
    process.exit(0);
  }

  // Code generation mode
  if (opts.codegen) {
    await generateCode(opts);
    process.exit(0);
  }

  // Validation mode
  if (!opts.targetPath) {
    console.error('Error: Missing target path (or use --doc/--codegen)');
    console.log(help);
    process.exit(1);
  }

  await validate(opts);
}

main().catch(err => {
  console.error(`Error: ${err.message}`);
  process.exit(1);
});
